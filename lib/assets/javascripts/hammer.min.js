/*! Hammer.JS - v1.0.6dev - 2013-04-10
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

((t, e) ->
  n = ->
    unless i.READY
      i.event.determineEventTypes()
      for t of i.gestures
        i.gestures.hasOwnProperty(t) and i.detection.register(i.gestures[t])
      i.event.onTouch(i.DOCUMENT, i.EVENT_MOVE, i.detection.detect)
      i.event.onTouch(i.DOCUMENT, i.EVENT_END, i.detection.detect)
      i.READY = not 0
  "use strict"
  i = (t, e) ->
    new i.Instance(t, e or {})

  i.defaults = stop_browser_behavior:
    userSelect: "none"
    touchAction: "none"
    touchCallout: "none"
    contentZooming: "none"
    userDrag: "none"
    tapHighlightColor: "rgba(0,0,0,0)"

  i.HAS_POINTEREVENTS = navigator.pointerEnabled or navigator.msPointerEnabled
  i.HAS_TOUCHEVENTS = "ontouchstart" of t
  i.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i
  i.NO_MOUSEEVENTS = i.HAS_TOUCHEVENTS and navigator.userAgent.match(i.MOBILE_REGEX)
  i.EVENT_TYPES = {}
  i.DIRECTION_DOWN = "down"
  i.DIRECTION_LEFT = "left"
  i.DIRECTION_UP = "up"
  i.DIRECTION_RIGHT = "right"
  i.POINTER_MOUSE = "mouse"
  i.POINTER_TOUCH = "touch"
  i.POINTER_PEN = "pen"
  i.EVENT_START = "start"
  i.EVENT_MOVE = "move"
  i.EVENT_END = "end"
  i.DOCUMENT = document
  i.plugins = {}
  i.READY = not 1
  i.Instance = (t, e) ->
    r = this
    n()
    @element = t
    @enabled = not 0
    @options = i.utils.extend(i.utils.extend({}, i.defaults), e or {})
    @options.stop_browser_behavior and i.utils.stopDefaultBrowserBehavior(@element, @options.stop_browser_behavior)
    i.event.onTouch(t, i.EVENT_START, (t) ->
      r.enabled and i.detection.startDetect(r, t)
    )
    this

  i.Instance:: =
    on: (t, e) ->
      n = t.split(" ")
      i = 0

      while n.length > i
        @element.addEventListener n[i], e, not 1
        i++
      this

    off: (t, e) ->
      n = t.split(" ")
      i = 0

      while n.length > i
        @element.removeEventListener n[i], e, not 1
        i++
      this

    trigger: (t, e) ->
      n = i.DOCUMENT.createEvent("Event")
      n.initEvent(t, not 0, not 0)
      n.gesture = e

      r = @element
      i.utils.hasParent(e.target, r) and (r = e.target)
      r.dispatchEvent(n)
      this

    enable: (t) ->
      @enabled = t
      this


  r = null
  o = not 1
  s = not 1
  i.event =
    bindDom: (t, e, n) ->
      i = e.split(" ")
      r = 0

      while i.length > r
        t.addEventListener i[r], n, not 1
        r++

    onTouch: (t, e, n) ->
      a = this
      @bindDom t, i.EVENT_TYPES[e], (c) ->
        u = c.type.toLowerCase()
        if not u.match(/mouse/) or not s
          (if u.match(/touch/) or u.match(/pointerdown/) or u.match(/mouse/) and 1 is c.which then o = not 0 else u.match(/mouse/) and 1 isnt c.which and (o = not 1))
          u.match(/touch|pointer/) and (s = not 0)

          h = 0
          o and ((if i.HAS_POINTEREVENTS and e isnt i.EVENT_END then h = i.PointerEvent.updatePointer(e, c) else (if u.match(/touch/) then h = c.touches.length else s or (h = (if u.match(/up/) then 0 else 1))))
          (if h > 0 and e is i.EVENT_END then e = i.EVENT_MOVE else h or (e = i.EVENT_END))
          (if h or null is r then r = c else c = r)
          n.call(i.detection, a.collectEventData(t, e, c))
          i.HAS_POINTEREVENTS and e is i.EVENT_END and (h = i.PointerEvent.updatePointer(e, c))
          )
          h or (r = null
          o = not 1
          s = not 1
          i.PointerEvent.reset()
          )


    determineEventTypes: ->
      t = undefined
      t = (if i.HAS_POINTEREVENTS then i.PointerEvent.getEvents() else (if i.NO_MOUSEEVENTS then ["touchstart", "touchmove", "touchend touchcancel"] else ["touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup"]))
      i.EVENT_TYPES[i.EVENT_START] = t[0]
      i.EVENT_TYPES[i.EVENT_MOVE] = t[1]
      i.EVENT_TYPES[i.EVENT_END] = t[2]

    getTouchList: (t) ->
      (if i.HAS_POINTEREVENTS then i.PointerEvent.getTouchList() else (if t.touches then t.touches else [
        identifier: 1
        pageX: t.pageX
        pageY: t.pageY
        target: t.target
      ]))

    collectEventData: (t, e, n) ->
      r = @getTouchList(n, e)
      o = i.POINTER_TOUCH
      (n.type.match(/mouse/) or i.PointerEvent.matchType(i.POINTER_MOUSE, n)) and (o = i.POINTER_MOUSE)

        center: i.utils.getCenter(r)
        timeStamp: (new Date).getTime()
        target: n.target
        touches: r
        eventType: e
        pointerType: o
        srcEvent: n
        preventDefault: ->
          @srcEvent.preventManipulation and @srcEvent.preventManipulation()
          @srcEvent.preventDefault and @srcEvent.preventDefault()

        stopPropagation: ->
          @srcEvent.stopPropagation()

        stopDetect: ->
          i.detection.stopDetect()

  i.PointerEvent =
    pointers: {}
    getTouchList: ->
      t = this
      e = []
      Object.keys(t.pointers).sort().forEach((n) ->
        e.push t.pointers[n]
      )
      e

    updatePointer: (t, e) ->
      (if t is i.EVENT_END then @pointers = {} else (e.identifier = e.pointerId
      @pointers[e.pointerId] = e
      ))
      Object.keys(@pointers).length

    matchType: (t, e) ->
      return not 1  unless e.pointerType
      n = {}
      n[i.POINTER_MOUSE] = e.pointerType is e.MSPOINTER_TYPE_MOUSE or e.pointerType is i.POINTER_MOUSE
      n[i.POINTER_TOUCH] = e.pointerType is e.MSPOINTER_TYPE_TOUCH or e.pointerType is i.POINTER_TOUCH
      n[i.POINTER_PEN] = e.pointerType is e.MSPOINTER_TYPE_PEN or e.pointerType is i.POINTER_PEN
      n[t]

    getEvents: ->
      ["pointerdown MSPointerDown", "pointermove MSPointerMove", "pointerup pointercancel MSPointerUp MSPointerCancel"]

    reset: ->
      @pointers = {}

  i.utils =
    extend: (t, n, i) ->
      for r of n
        t[r] isnt e and i or (t[r] = n[r])
      t

    hasParent: (t, e) ->
      while t
        return not 0  if t is e
        t = t.parentNode
      not 1

    getCenter: (t) ->
      e = []
      n = []
      i = 0
      r = t.length

      while r > i
        e.push(t[i].pageX)
        n.push(t[i].pageY)
        i++
      pageX: (Math.min.apply(Math, e) + Math.max.apply(Math, e)) / 2
      pageY: (Math.min.apply(Math, n) + Math.max.apply(Math, n)) / 2

    getVelocity: (t, e, n) ->
      x: Math.abs(e / t) or 0
      y: Math.abs(n / t) or 0

    getAngle: (t, e) ->
      n = e.pageY - t.pageY
      i = e.pageX - t.pageX
      180 * Math.atan2(n, i) / Math.PI

    getDirection: (t, e) ->
      n = Math.abs(t.pageX - e.pageX)
      r = Math.abs(t.pageY - e.pageY)
      (if n >= r then (if t.pageX - e.pageX > 0 then i.DIRECTION_LEFT else i.DIRECTION_RIGHT) else (if t.pageY - e.pageY > 0 then i.DIRECTION_UP else i.DIRECTION_DOWN))

    getDistance: (t, e) ->
      n = e.pageX - t.pageX
      i = e.pageY - t.pageY
      Math.sqrt n * n + i * i

    getScale: (t, e) ->
      (if t.length >= 2 and e.length >= 2 then @getDistance(e[0], e[1]) / @getDistance(t[0], t[1]) else 1)

    getRotation: (t, e) ->
      (if t.length >= 2 and e.length >= 2 then @getAngle(e[1], e[0]) - @getAngle(t[1], t[0]) else 0)

    isVertical: (t) ->
      t is i.DIRECTION_UP or t is i.DIRECTION_DOWN

    stopDefaultBrowserBehavior: (t, e) ->
      n = undefined
      i = ["webkit", "khtml", "moz", "ms", "o", ""]
      if e and t.style
        r = 0

        while i.length > r
          for o of e
            e.hasOwnProperty(o) and (n = o
            i[r] and (n = i[r] + n.substring(0, 1).toUpperCase() + n.substring(1))
            t.style[n] = e[o]
            )
          r++
        "none" is e.userSelect and (t.onselectstart = ->
          not 1
        )

  i.detection =
    gestures: []
    current: null
    previous: null
    stopped: not 1
    startDetect: (t, e) ->
      @current or (@stopped = not 1
      @current =
        inst: t
        startEvent: i.utils.extend({}, e)
        lastEvent: not 1
        name: ""

      @detect(e)
      )

    detect: (t) ->
      if @current and not @stopped
        t = @extendEventData(t)
        e = @current.inst.options
        n = 0
        r = @gestures.length

        while r > n
          o = @gestures[n]
          if not @stopped and e[o.name] isnt not 1 and o.handler.call(o, t, @current.inst) is not 1
            @stopDetect()
            break
          n++
        @current and (@current.lastEvent = t)
        t.eventType is i.EVENT_END and not t.touches.length - 1 and @stopDetect()
        t

    stopDetect: ->
      @previous = i.utils.extend({}, @current)
      @current = null
      @stopped = not 0

    extendEventData: (t) ->
      e = @current.startEvent
      if e and (t.touches.length isnt e.touches.length or t.touches is e.touches)
        e.touches = []
        n = 0
        r = t.touches.length

        while r > n
          e.touches.push i.utils.extend({}, t.touches[n])
          n++
      o = t.timeStamp - e.timeStamp
      s = t.center.pageX - e.center.pageX
      a = t.center.pageY - e.center.pageY
      c = i.utils.getVelocity(o, s, a)
      i.utils.extend(t,
        deltaTime: o
        deltaX: s
        deltaY: a
        velocityX: c.x
        velocityY: c.y
        distance: i.utils.getDistance(e.center, t.center)
        angle: i.utils.getAngle(e.center, t.center)
        direction: i.utils.getDirection(e.center, t.center)
        scale: i.utils.getScale(e.touches, t.touches)
        rotation: i.utils.getRotation(e.touches, t.touches)
        startEvent: e
      )
      t

    register: (t) ->
      n = t.defaults or {}
      n[t.name] is e and (n[t.name] = not 0)
      i.utils.extend(i.defaults, n, not 0)
      t.index = t.index or 1e3
      @gestures.push(t)
      @gestures.sort((t, e) ->
        (if t.index < e.index then -1 else (if t.index > e.index then 1 else 0))
      )
      @gestures

  i.gestures = i.gestures or {}
  i.gestures.Hold =
    name: "hold"
    index: 10
    defaults:
      hold_timeout: 500
      hold_threshold: 1

    timer: null
    handler: (t, e) ->
      switch t.eventType
        when i.EVENT_START
          clearTimeout(@timer)
          i.detection.current.name = @name
          @timer = setTimeout(->
            "hold" is i.detection.current.name and e.trigger("hold", t)
          , e.options.hold_timeout)
        when i.EVENT_MOVE
          t.distance > e.options.hold_threshold and clearTimeout(@timer)
        when i.EVENT_END
          clearTimeout @timer

  i.gestures.Tap =
    name: "tap"
    index: 100
    defaults:
      tap_max_touchtime: 250
      tap_max_distance: 10
      tap_always: not 0
      doubletap_distance: 20
      doubletap_interval: 300

    handler: (t, e) ->
      if t.eventType is i.EVENT_END
        n = i.detection.previous
        r = not 1
        return  if t.deltaTime > e.options.tap_max_touchtime or t.distance > e.options.tap_max_distance
        n and "tap" is n.name and t.timeStamp - n.lastEvent.timeStamp < e.options.doubletap_interval and t.distance < e.options.doubletap_distance and (e.trigger("doubletap", t)
        r = not 0
        )
        (not r or e.options.tap_always) and (i.detection.current.name = "tap"
        e.trigger(i.detection.current.name, t)
        )

  i.gestures.Swipe =
    name: "swipe"
    index: 40
    defaults:
      swipe_max_touches: 1
      swipe_velocity: .7

    handler: (t, e) ->
      if t.eventType is i.EVENT_END
        return  if e.options.swipe_max_touches > 0 and t.touches.length > e.options.swipe_max_touches
        (t.velocityX > e.options.swipe_velocity or t.velocityY > e.options.swipe_velocity) and (e.trigger(@name, t)
        e.trigger(@name + t.direction, t)
        )

  i.gestures.Drag =
    name: "drag"
    index: 50
    defaults:
      drag_min_distance: 10
      drag_max_touches: 1
      drag_block_horizontal: not 1
      drag_block_vertical: not 1
      drag_lock_to_axis: not 1
      drag_lock_min_distance: 25

    triggered: not 1
    handler: (t, n) ->
      if i.detection.current.name isnt @name and @triggered
        return n.trigger(@name + "end", t)
        @triggered = not 1
        e
      unless n.options.drag_max_touches > 0 and t.touches.length > n.options.drag_max_touches
        switch t.eventType
          when i.EVENT_START
            @triggered = not 1
          when i.EVENT_MOVE
            return  if t.distance < n.options.drag_min_distance and i.detection.current.name isnt @name
            i.detection.current.name = @name
            (i.detection.current.lastEvent.drag_locked_to_axis or n.options.drag_lock_to_axis and n.options.drag_lock_min_distance <= t.distance) and (t.drag_locked_to_axis = not 0)

            r = i.detection.current.lastEvent.direction
            t.drag_locked_to_axis and r isnt t.direction and (t.direction = (if i.utils.isVertical(r) then (if 0 > t.deltaY then i.DIRECTION_UP else i.DIRECTION_DOWN) else (if 0 > t.deltaX then i.DIRECTION_LEFT else i.DIRECTION_RIGHT)))
            @triggered or (n.trigger(@name + "start", t)
            @triggered = not 0
            )
            n.trigger(@name, t)
            n.trigger(@name + t.direction, t)
            (n.options.drag_block_vertical and i.utils.isVertical(t.direction) or n.options.drag_block_horizontal and not i.utils.isVertical(t.direction)) and t.preventDefault()
          when i.EVENT_END
            @triggered and n.trigger(@name + "end", t)
            @triggered = not 1

  i.gestures.Transform =
    name: "transform"
    index: 45
    defaults:
      transform_min_scale: .01
      transform_min_rotation: 1
      transform_always_block: not 1

    triggered: not 1
    handler: (t, n) ->
      if i.detection.current.name isnt @name and @triggered
        return n.trigger(@name + "end", t)
        @triggered = not 1
        e
      unless 2 > t.touches.length
        switch n.options.transform_always_block and t.preventDefault()
        t.eventType

          when i.EVENT_START
            @triggered = not 1
          when i.EVENT_MOVE
            r = Math.abs(1 - t.scale)
            o = Math.abs(t.rotation)
            return  if n.options.transform_min_scale > r and n.options.transform_min_rotation > o
            i.detection.current.name = @name
            @triggered or (n.trigger(@name + "start", t)
            @triggered = not 0
            )
            n.trigger(@name, t)
            o > n.options.transform_min_rotation and n.trigger("rotate", t)
            r > n.options.transform_min_scale and (n.trigger("pinch", t)
            n.trigger("pinch" + ((if 1 > t.scale then "in" else "out")), t)
            )
          when i.EVENT_END
            @triggered and n.trigger(@name + "end", t)
            @triggered = not 1

  i.gestures.Touch =
    name: "touch"
    index: -1 / 0
    defaults:
      prevent_default: not 1
      prevent_mouseevents: not 1

    handler: (t, n) ->
      (if n.options.prevent_mouseevents and t.pointerType is i.POINTER_MOUSE then (t.stopDetect()
      e
      ) else (n.options.prevent_default and t.preventDefault()
      t.eventType is i.EVENT_START and n.trigger(@name, t)
      e
      ))

  i.gestures.Release =
    name: "release"
    index: 1 / 0
    handler: (t, e) ->
      t.eventType is i.EVENT_END and e.trigger(@name, t)

  (if "object" is typeof module and "object" is typeof module.exports then module.exports = i else (t.Hammer = i
  "function" is typeof t.define and t.define.amd and t.define("hammer", [], ->
    i
  )
  ))
) this